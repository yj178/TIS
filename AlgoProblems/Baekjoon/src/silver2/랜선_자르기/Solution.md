# 랜선 자르기

## 기호 설명
K : 이미 가지고 있는 랜선의 개수
N : 같은 길이로 가지고 있어야 하는 랜선의 개수

## 제약 조건
* $1 \leq K \leq 10,000$
* $1 \leq N \leq 1,000,000$
* $K \leq N$
* 랜선의 최대 길이 $2^{31} - 1$

랜선의 최대 길이는 $2^{31} - 1$이므로, 혹여 랜선의 길이를 더하는 경우에는 int가 아닌 long을 사용해야 한다.

## 풀이 과정
해당 문제에서 구하고자 하는 값은 랜선의 최대 길이이다.   
랜선의 길이 범위는 $2^{31} - 1$이므로 하나씩 확인한다면 최악의 경우 이십억 번 확인해야 한다.    
이러한 경우 이진 탐색을 활용하면 빠르게 약 30번의 확인 작업으로 길이를 구할 수 있다.   
이렇게 임의의 값을 정하고 가능한 답인지 확인하면서 범위를 좁혀나가는 방식을 파라메트릭 서치라고 한다.   

```java
static long parametricSearch(long s, long e) {
    if (s == e) return e;

    long m = (s + e + 1) >>> 1;
    if (chk(m)) return parametricSearch(m, e);
    else return parametricSearch(s, m - 1);
}
```

탐색 조건은 위의 코드와 같다.

chk(m)으로 중간값의 길이가 가능한지 판단한다. 만약 가능하다면, 현재 숫자를 포함해(가장 큰 숫자일 수 있으므로) 마지막까지 범위로 설정한다.   
아니라면 처음부터 중간값의 이전값(m - 1)까지 탐색 범위로 설정한다.

중간값을 (s + e) / 2가 아닌, (s + e + 1) / 2로 설정했는데, 이는 경계 조건에 의해 결정된다.

(s, m - 1)과 (m, e)의 경계로 나누는데, 이러한 경우 평균값을 (s + e) / 2로 설정한다면 다음과 같은 문제가 발생한다.
* 1을 찾고자 하는 상황이며, s = 1, e = 2인 경우 m은 1이 되고, (1, 2)로 탐색하는 무한 재귀에 빠져 스택 오버플로를 발생한다.
* 2를 찾고자 하는 상황에서, s = 1, e = 2인 경우 m은 1이 되고, (1, 0)로 탐색하는 무한 재귀에 빠져 스택 오버플로가 발생한다.

위의 코드와 같이 (s + e + 1) / 2로 평균값을 설정하는 경우, 다음과 같이 결정된다.
* 1을 찾고자 하는 상황이며, s = 1, e = 2인 경우 m은 2가 되고, (1, 1)로 탐색하여 재귀 종료조건을 만족시킨다.
* 2를 찾고자 하는 상황에서, s = 1, e = 2인 경우 m은 2가 되고, (2, 2)로 탐색하여 재귀 종료조건을 만족시킨다.

평균값 m이 조건을 만족하는지 확인하는 chk 메서드는 다음과 같은 방식으로 확인한다.   
1. 가지고 있는 케이블을 순회하면서 임의로 정한 m의 길이 자른 개수를 더한다.
   1. 이때, 길이가 m인 케이블이 N개 이상이 된다면, return true
2. 순회를 종료된다면(== cnt < N), return false

* N이 1,000,000 이하라서 큰 문제는 없겠지만, 범위가 커진다면 cnt를 int가 아닌 long 사용해야 하는 경우가 발생할 수 있다. 