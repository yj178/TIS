# [Codetree] [Gold4 격자_숫자_놀이](https://www.codetree.ai/training-field/frequent-problems/matrix-number-play/description?page=2&pageSize=20)

## 목표
> 격자판의 (r, c)의 값이 원하는 값이 되는데까지 걸리는 시간을 구하시오.
## 문제 조건
### 기호 설명
* r : 원하는 값의 행의 위치
* c : 원하는 값의 열의 위치
* k : 원하는 값
* $A(r, c)$ : r, c의 위치의 값
### 기호 범위
* $1 \leq r, c, k \leq 100$
* $1 \leq A(r, c) \leq 100$
### 문제 절차
* 행의 개수가 열의 개수보다 크거나 같은 경우
  * 모든 행에 대하여 정렬을 수행
    * 정렬 기준은 출현 빈도 수가 적은 순서대로
    * 만약 출현 횟수가 같다면 해당 숫자가 작은 순서대로
    * 정렬 수행 시 숫자와 해당하는 숫자의 출현 빈도 수를 함께 출력 -> 해당 숫자, 출현 빈도
* 행의 개수가 열의 개수보다 작은 경우
  * 모든 열에 대해 행의 정렬과 같은 과정을 수행
* 행이나 열의 길이가 100을 넘어가는 경우에는 처음 100개의 격자를 제외하고 모두 버림

## 추가로 고려해야 할 사항
* 격자를 생성하는 과정에서 100 * 100 * 100가 최대치이므로 효율에 너무 신경쓰지 않아도 해결 가능
* 숫자의 값와 빈도를 고려하여 정렬이 가능한 자료 구조
  * HashMap으로 빈도 계산 가능
  * PriorityQueue로 정렬 가능
  * TreeMap으로 정렬 가능
* 격자의 크기가 유동적
  * HashMap 결과를 이용하여 결정
  * int[][]을 사용
## 풀기 전 생각한 풀이 과정
* 격자는 int[][]로 관리
* HashMap[]을 이용하여 행 혹은 열의 숫자 빈도 파악
  
* 초기 입력 수행
  * 최대 100번 아래 과정을 수행
  * 행과 열의 크기를 비교하여 어떤 방향으로 탐색할지 결정
    * 해당 방향의 숫자 빈도를 파악
      * 해당 과정에서 HashMap의 최대치를 갱신
    * HashMap사이즈 최대치 * 2와 100 중 최소치로 격자의 크기 결정
  * 격자에 크기 순으로 배치
    * 이때, $(r, c)$의 값이 k라면 회차를 return
  * 100번 수행 과정에서 값을 도달하지 못하면 -1을 return

## 풀면서 추가로 고려한 사항
* 입력과 동시에 답인 0인 케이스 고려하지 못함
  * 시작하자마자 조건이 성립하는지 확인
* R, C가 현재의 격자보다 큰 경우 고려하지 못함
  * 현재 지도의 크기보다 큰 경우 확인하지 못하도록 로직을 추가함

## 결과 & 느낀 점
* 시작 시각 : 10:03
* 종료 시각 : 11:12
* 소요 시간 : 69분
