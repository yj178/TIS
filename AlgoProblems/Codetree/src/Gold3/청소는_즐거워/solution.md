# [Codetree] [Gold3 청소는_즐거워](https://www.codetree.ai/training-field/frequent-problems/cleaning-is-joyful/description?page=2&pageSize=20)

## 목표
> 
## 문제 조건
### 기호 설명
* n : 격자의 크기
### 기호 범위
* $3 \leq n \leq 499, (n은 홀수)$
* $0 \leq 먼지의 양 \leq 1000$
### 문제 절차
* n*n 바닥을 나선형으로 청소를 수행
  * n은 항상 홀수로 주어지고, 처음에 정가운데 격자에는 먼지가 존재하지 않는다.
  * 왼쪽, 아래쪽, 오른쪽, 위쪽 순서로 이동하며 청소를 진행
  * n이 홀수이기 때문에 항상 0,0에서 청소 종료
  * 빗자루가 이동할 때 마다 먼지의 변화는 다음과 같다.
    * 빗자루가 이동한 위치의 격자에 있는 먼지가 함께 이동한다.
    * 이동한 먼지는 기존의 먼지와 합쳐진다.
    * 빗자루가 이동한 위치의 먼지는 모두 없어진다.
      * a%에 해당하는 먼지 양은 다른 격자에 이동한 먼지의 양을 모두 합한 것을 이동한 위치에 있던 먼지의 양에서 빼고 남은 먼지에 해당한다.
      * 비율을 곱해줄 때 소숫점 아래의 숫자는 버림해준다.


## 추가로 고려해야 할 사항
* 먼지의 양은 최대값이 $250000 \times 1000 = 250,000,000$이므로 int형으로 관리가 가능하다.
* 방향에 따라 먼지가 퍼지는 값이 다르므로 이를 고려해야 한다.
* 퍼지는 먼지의 양을 기록하고 남은 값을 알아야 한다.
  
## 풀기 전 생각한 풀이 과정
### 전역으로 관리할 변수
* 격자에 존재하는 먼지
* 빗자루의 현재 위치
* 빗자루가 현재 바라보는 방향
* 방향에 따른 다음 위치 변동량

### 필요한 로직
* 청소하는 방향을 회전하는 위치인지 확인할 수 있는 로직 구현하기
  * 방향은 0 : 왼쪽, 1 : 아래, 2 : 오른쪽, 3 : 위쪽
  * 좌상이 0,0
  * 0,0에서 청소 후 종료
  * 왼쪽 -> 아래 : r은 N/2 이하이고 r - 1 = c인 경우
  * 아래 -> 오른쪽 : r은 N/2 보다 크고 N - 1 - r == c인 경우
  * 오른쪽 -> 위 : r은 N/2 보다 크고 r == c인 경우
  * 위 -> 왼쪽 : r은 N/2보다 작고 r = N - 1 - c인 경우
* 바라보는 방향을 기준으로 먼지가 퍼지는 기능 구현하기
  * 현재 위치에서 바라보는 방향으로 2칸 간 경우 : 현재 위치의 먼지 * / 20
  * 현재 위치에서 1칸 간 후 오른쪽/왼족 한칸인 경우 : 현재 위치의 먼지 / 10
  * 현재 위치에서 오른쪽/왼쪽 2칸 간 경우 : 현재 위치의 먼지 / 50
  * 현재 위치에서 오른쪽/왼쪽 1칸 간 경우 : 현재 위치의 먼지 * 7 / 100
  * 현재 위치에서 뒤로 1칸 간 후 오른쪽/왼쪽 한칸 간 경우 : 현재 위치의 먼지 / 100
  * 앞으로 1칸에는 현재 칸 먼지에서 위의 먼지들 양을 제외한 먼지양
  
* while문으로 현재 위치가 0,0인 경우에 동작 후 종료하도록 함
  * 바라보는 방향으로 이동
  * 해당 방향으로 청소 수행
  * 이때, 이동한 위치가 방향을 바꿔야 하는 경우 방향 전환
  * 청소 수행 과정에서 격자 밖으로 벗어난 먼지 누적하여 기록
* while문 종료 후 누적 먼지 출력

## 풀면서 추가로 고려한 사항
없습니다

## 느낀 점
* 시작 시각 : 16:53
* 종료 시각 : 18:10
* 소요 시간 : 67분
  
간만에 한번에 맞은 문제입니다.
풀이 방법 생각하는 과정에서 최대한 정확하게 작성하고 넘어가는게 정확도가 가장 좋습니다.