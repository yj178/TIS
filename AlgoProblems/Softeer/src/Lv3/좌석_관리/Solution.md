# Lv3.좌석_관리

## 기호 설명
* $N$ : 식당의 행 크기
* $M$ : 식당의 열 크기
* $K$ : 현재 좌석을 차지하고 있는 인원의 수
* $i$ : 좌석을 차지하고 있는 인원의 번호
* $x_i$ : 좌석을 차지하고 있는 인원 중 i번째 인원의 행의 위치
* $y_i$ : 좌석을 차지하고 있는 인원 중 i번째 인원의 열의 위치
* $D_{x,y}$ : $(x, y)$에 위치한 식당 좌석의 안전도 (현재 식당에 앉아 있는 인원에 의해 영향을 받음) 

## 제약 조건
* $1 \leq N, M \leq 20$
* $1 \leq Q \leq 3\times 10^4$
* $1 \leq id \leq 10^4$

java의 경우 시간 제한이 5초라서 매우 여유롭다.   
식당의 최대 크기는 400이고, 최대 10,000개의 명령어를 처리해야 한다.

## 풀이 과정
문제를 읽어보면 아래와 같이 관리해야할 대상 3가지를 파악할 수 있다.   
1. 작업이 수행될 때, 해당 인원은 현재 무슨 상태인지?
2. 인원이 식당에 앉은 경우 앉을 수 있는 좌석 위치는 어디인지? 
3. 앉을 수 있는 좌석 중 가장 안전한 좌석은 어디인지?

인원의 id와 상태(식사여부, 좌석 위치)를 각각 HashMap의 key와 value로 관리하였으며, 상태는 아래와 같다.   
* $state.value < 0$인 경우 : 아직 식사를 하지 못함
* $state.value >= 0 \cup state.value < 400$인 경우 : 현재 식사를 하고 있는 중이며, 0~399 사이의 자리에 앉아 있음 
* $state.value >= 400$인 경우 : 식사를 마무리하고 식당을 떠남

이렇게 관리한다면 관리해야 할 대상 중 1번과 2번을 한 번에 관리할 수 있다.   

그럼 이제 인원에게 좌석을 배정해 줄 때, 앉을 수 있는 좌석의 여부와 가장 안전한 좌석의 위치를 파악하는 방법에 대해 생각해 보자.   
3번을 파악하기 위해서는 아래와 같이
* 현재 앉아 있는 인원의 위치
* 현재 앉을 수 있는 위치
* 위치별 안전도 점수

앉아 있는 위치는 TreeSet으로 관리한다면, 빠르게 탐색할 수 있다.   
현재 앉을 수 있는 위치의 경우 boolean[][]으로 관리하였다.   
~~메모리 사용량을 줄이고 싶다면 매 좌석마다 4방 탐색으로 TreeSet에 좌석이 존재하는지 확인하는 것도 방법일 것 같다.~~
위치별 안전도 점수의 경우 앉을 수 있는 위치마다 앉아 있는 위치를 조회하면서 최솟값을 찾아야 한다.   
그리고 직원에게 배정할 때는 안전도 점수가 가장 큰 좌석을 배정해야 한다.   
해당 부분은 Priority Queue를 두 번 이용해서 간단하게 찾았다.   

유사한 문제들을 풀면서 TreeSet과 Priority Queue를 활용법을 익혀둔 것이 큰 도움이 되었다.




