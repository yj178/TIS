# Lv3.등산코스_정하기

## 목표
> 휴식 시간을 이동하는 시간(intensity)이 가장 짧은 등산코스 정하기

## 문제 조건
* 2 ≤ n ≤ 50,000
* n - 1 ≤ paths의 길이 ≤ 200,000
* paths의 원소는 [i, j, w] 형태입니다.
  * i번 지점과 j번 지점을 연결하는 등산로가 있다는 뜻입니다.
  * w는 두 지점 사이를 이동하는 데 걸리는 시간입니다.
  * 1 ≤ i < j ≤ n
  * 1 ≤ w ≤ 10,000,000
  * 서로 다른 두 지점을 직접 연결하는 등산로는 최대 1개입니다.
* 1 ≤ gates의 길이 ≤ n
  * 1 ≤ gates의 원소 ≤ n
  * gates의 원소는 해당 지점이 출입구임을 나타냅니다.
* 1 ≤ summits의 길이 ≤ n
  * 1 ≤ summits의 원소 ≤ n
  * summits의 원소는 해당 지점이 산봉우리임을 나타냅니다.
* 출입구이면서 동시에 산봉우리인 지점은 없습니다.
* gates와 summits에 등장하지 않은 지점은 모두 쉼터입니다.
* 임의의 두 지점 사이에 이동 가능한 경로가 항상 존재합니다.
* return 하는 배열은 [산봉우리의 번호, intensity의 최솟값] 순서여야 합니다.

## 추가로 고려해야 할 사항

## 풀기 전 생각한 풀이 과정
각 산봉우리에서 출입구까지의 intensity를 구하면 이들 중 최소의 intensity를 가지고, 가장 적은 산봉우리를 가지는 것을 찾는 방식으로 접근해 봅니다.
* 산봉우리, 입구, 방문장소는 모두 HashSet으로, 경로는 Node와 ArrayList로 관리합니다.
* dfs로 모든 봉우리에서 탐색을 진행합니다.
* 출입구에 도달한 경우 정보를 Priority Queue에 저장합니다.
* 모든 봉우리에 대해 탐색을 진행했다면 Priority Queue에서 정보를 추출하여 return합니다.


## 풀면서 추가로 고려한 사항
처음 풀었을 때, dfs를 응용해서 문제를 해결하려 했지만 시간 초과가 발생했습니다.   
한동안 최소신장트리, 최단거리와 관련된 문제를 풀지 않아 다익스트라로 해결해야 하는것이 바로 떠오르지 않았습니다.   
다익스트라로 문제를 해결할 때 필요한 요소   
* 탐색할 경로의 그래프
* 방문시 최단 거리를 갱신할 저장 공간

1. 등산로에 대해 graph 생성
2. 정상을 HashSet으로 관리
3. 다익스트라를 활용하여 모든 등산로 입구에서 출발하여 정상에 도달하는 최단 intensity를 PriorityQueue에 저장함
4. 우선 순위가 가장 높은 결과를 출력함

## 느낀 점
과거 MST를 많이 풀면서 적응했지만 간만에 관련 문제를 접했더니 풀이 방법이 바로 떠오르지 않았습니다.   
풀이 방법을 어느 정도 알고 있다면 여러 문제를 풀면서 익숙해져야겠습니다.
